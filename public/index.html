// =======================
// Facebook Auto Comment Tool - v1.5 Fixed
// =======================

const stats = {
    success: 0,
    failed: 0,
    badPosts: 0,
    invalidTokens: 0,
    expiredTokens: 0,
    blocked: 0
};

let stopFlag = false;

// ----------------- Utility -----------------
function logFeed(message, type = "info") {
    const feedBox = document.getElementById("live-feed");
    const entry = document.createElement("div");
    entry.className = `feed-item ${type}`;
    entry.innerText = `[${new Date().toLocaleTimeString()}] ${message}`;
    feedBox.prepend(entry);
}

function updateStats() {
    document.getElementById("success-count").innerText = stats.success;
    document.getElementById("failed-count").innerText = stats.failed;
    document.getElementById("badpost-count").innerText = stats.badPosts;
    document.getElementById("invalid-count").innerText = stats.invalidTokens;
    document.getElementById("expired-count").innerText = stats.expiredTokens;
    document.getElementById("blocked-count").innerText = stats.blocked;
}

// ----------------- Post ID Extract -----------------
function extractPostId(linkOrId) {
    // Direct numeric ID
    if (/^\d+$/.test(linkOrId)) return linkOrId;

    // Facebook link patterns
    try {
        let url = new URL(linkOrId);
        if (url.searchParams.get("story_fbid")) {
            return url.searchParams.get("story_fbid");
        }
        if (url.pathname.includes("/posts/")) {
            return url.pathname.split("/posts/")[1].split("/")[0];
        }
        if (url.pathname.includes("/videos/")) {
            return url.pathname.split("/videos/")[1].split("/")[0];
        }
    } catch (e) {
        return null;
    }
    return null;
}

// ----------------- Comment Function -----------------
async function commentOnPost(postId, message, token, tokenIndex, postIndex) {
    const url = `https://graph.facebook.com/${postId}/comments`;
    try {
        let response = await fetch(url, {
            method: "POST",
            body: new URLSearchParams({
                message: message,
                access_token: token
            })
        });
        let data = await response.json();

        if (data.error) {
            let code = data.error.code;
            if (code === 190) {
                stats.expiredTokens++;
                logFeed(`‚ùå Token ${tokenIndex} expired/invalid (Post ${postIndex})`, "error");
            } else if (code === 200) {
                stats.invalidTokens++;
                logFeed(`‚ö†Ô∏è Token ${tokenIndex} missing permission (Post ${postIndex})`, "warn");
            } else if (code === 368) {
                stats.blocked++;
                logFeed(`üö´ Token ${tokenIndex} temporarily blocked (Post ${postIndex})`, "error");
            } else {
                stats.failed++;
                logFeed(`‚ùå Failed (Token ${tokenIndex}, Post ${postIndex}): ${data.error.message}`, "error");
            }
        } else {
            stats.success++;
            logFeed(`‚úÖ Commented on Post ${postIndex} with Token ${tokenIndex}`, "success");
        }
    } catch (err) {
        stats.failed++;
        logFeed(`‚ùå Network error (Token ${tokenIndex}, Post ${postIndex})`, "error");
    }
    updateStats();
}

// ----------------- Main Runner -----------------
async function startComments(posts, comments, tokens, delay, maxComments) {
    stopFlag = false;
    let count = 0;

    for (let t = 0; t < tokens.length; t++) {
        for (let p = 0; p < posts.length; p++) {
            if (stopFlag) return;
            let postId = extractPostId(posts[p]);
            if (!postId) {
                stats.badPosts++;
                logFeed(`‚ö†Ô∏è Bad Post Link/ID at index ${p + 1}`, "warn");
                updateStats();
                continue;
            }

            let comment = comments[count % comments.length];
            await commentOnPost(postId, comment, tokens[t], t + 1, p + 1);

            count++;
            if (maxComments > 0 && count >= maxComments) {
                logFeed("‚úÖ Reached max comments limit", "success");
                return;
            }

            await new Promise(r => setTimeout(r, delay * 1000));
        }
    }
}

function stopComments() {
    stopFlag = true;
    logFeed("‚õî Commenting stopped by user", "warn");
}
